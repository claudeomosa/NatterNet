For this work, you are asked to implement a system in Elixir that allows users to broadcast messages to one another. 

The user connects to the system via TCP and issues commands. The are four supported commands: 

/LIST 
/NICK <nickname> 
/BC <message> 
/MSG <nickname> <message> 


The names of the commands are case-sensitive and each command is terminated by the end-of-line character sequence. 
In the above, <nickname> consists of one word (with restrictions specified below); <message> has one or more words.
 The /LIST command does not take any arguments: any words after it are ignored. The /NICK command takes one word as argument: any extra words are again ignored. A /NICK or /BC command by itself (i.e., with no following words) is invalid. The /MSG command must be followed by at least two words: the first word is a nickname and the rest the message; otherwise it is invalid. Any command other than the above four is also invalid. 

The /NICK command is used to set a nickname. For example, /NICK joey asks the server to use joey as the nickname for the user who issues that command. The server needs to ensure that the requested nickname is not in use before granting the request. The client will receive a response message indicating whether the operation is successful. 

There are also restrictions on what constitutes a valid nickname: it must start with an alphabet followed by characters that are either alphanumeric or the underscore character and it can have a maximum length of 12 characters. A user must succeed in setting a nickname before they can send, broadcast or receive messages. (However, the user is able to use the /LIST command without setting a nickname.) 

- The /LIST command is used to get a list of the nicknames currently in use. 
- The /BC command is used to broadcast a message to all other users. For example, /BC hi there sends the message "hello" to all other users. 
- The /MSG command is used to send a message to a specific user. For example, /MSG joey bye sends the message "bye" to the user with nickname homer.
 
The finer details of the design of the system is up to you. However, there must be one globally-registered supervised server that provides the main behaviour of dispatching messages and handling nicknames, i.e., it receives requests from other processes whenever messages need to be sent or broadcast and whenever a user needs to set or change their nickname. 

This server must use ETS table(s) to keep track of its state so that it can recover from (brief) crashes. We'll refer to this server as the broadcast server. Note that this server does not directly communicate with external clients (i.e., clients not running in an Elixir node). 

There is a second type of Elixir server responsible for accepting external clients that connect via TCP. This type of server is not registered and multiple instances of it can run. The server creates an Elixir process to handle each connecting client. From the point of view of each client, this Elixir process acts as a proxy for the broadcast server. It is this proxy process that parses and validates the commands the client sends and requests the broadcast server for services when necessary. This reduces the workload on the broadcast server as it does not need to deal directly with external clients. The proxy process sends messages from the broadcast server to its external client. It also sends error messages for invalid commands to external clients. Essentially, this second server is responsible for creating proxies. We'll refer to this server as the proxy server. 

Your mix project should be named chat. From the description above, it is clear that there must be at least two modules. Call them Chat. BroadcastServer and Chat. ProxyServer. Chat. BroadcastServer implements the globally-registered broadcast server. It uses GenServer. Chat. ProxyServer contains code to implement the proxy server that listens at a particular port (defaults to 6666) and spawns a proxy process whenever an external client connects to the system via TCP. 

You will also need to implement a suitable client in Java. It can takes a host and a port number as command-line arguments. (The host defaults to "localhost" and the port to 6666.) Basically, the program needs to connect to a proxy server, sends commands the user types to the proxy that is created as well as receiving and displaying replies from that proxy concurrently. It is essentially a dumb client and does not do command validation. 

The program terminates when the user enters the end-of-file key (at the beginning of a line when prompted for input). The system needs to remove the nickname when a client terminates.

To faciliate testing, the servers must print "debugging" information.


